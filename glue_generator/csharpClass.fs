module csharpGenerator

let headerWarning =
    "//This file is automatically generated by the F# glue code generator. 
//Any changes to this file _will_ be lost the next time you compile.
//Do NOT edit this file!"

type attrArgumentType =
    | String of string
    | Integer of string
    | Float of float
    | Float32 of float32
    | Null
    | Enum of (string * string)

type attr =
    { ty: string
      args: attrArgumentType list }

type Field =
    { name: string
      ty: string
      attributes: attr list }

type Generic = { name: string }

type Method =
    { name: string
      ret: string
      args: Field list
      generics: string list
      attributes: attr list }

type SignalHandler = { name: string; args: Field list }

type CsharpClass =
    { name: string
      extending: string
      fields: Field list
      methods: Method list
      signalHandlers: SignalHandler list
      attributes: attr list }

let typeToProxyType (ty: System.Type) =
    if ty.FullName = "System.Void" then "void" else ty.Name

let typeToSanitizedName (ty: System.Type) =
    if ty.FullName = "System.Void" then "void" else ty.FullName

let signalPrefix = "Emit"


let isSignalHandler (m: System.Reflection.MethodInfo) =
    m.IsAbstract
    && m.IsPublic
    && not m.IsGenericMethod
    && m.Name.StartsWith signalPrefix
    && m.GetCustomAttributes(true)
       |> Seq.exists (fun a -> a.GetType().FullName.Contains "FSharpSignalAttribute")

let rec isExtendingGodot (ty: System.Type) =
    if ty.Assembly.FullName.StartsWith "GodotSharp," then
        true
    else
        ty.BaseType <> null && isExtendingGodot ty.BaseType

let parseArgument (attributeName: string) (fieldName: string) (a: System.Reflection.CustomAttributeTypedArgument) =
    System.Console.WriteLine a.ArgumentType.FullName
    let isEnum = a.ArgumentType.BaseType.FullName.Contains "Enum"

    match a.Value with
    | :? string as s -> s |> String
    | :? int as i ->
        if isEnum then
            let enumName = a.ArgumentType.FullName
            let enumValue = a.Value.ToString()
            (enumName, enumValue) |> Enum
        else
            i.ToString() |> Integer
    | :? int64 as i ->
        if isEnum then
            let enumName = a.ArgumentType.FullName
            let enumValue = a.Value.ToString()
            (enumName, enumValue) |> Enum
        else
            i.ToString() |> Integer
    | :? float as f -> f |> Float
    | :? float32 as f -> f |> Float32
    | _ ->
        System.Console.Error.WriteLine
            $"Unknown argument type {a.Value.GetType()}. Attribute: {attributeName} Field: {fieldName}"

        Null

let getAttributes (fieldName: string) (a: seq<System.Reflection.CustomAttributeData>) =
    a
    |> Seq.filter (fun a -> isExtendingGodot a.AttributeType)
    |> Seq.map (fun a ->
        let args =
            a.ConstructorArguments
            |> Seq.map (fun ar -> parseArgument a.AttributeType.FullName fieldName ar)
            |> Seq.toList

        { ty = a.AttributeType.FullName
          args = args })

let fromTyToClass (ty: System.Type) =
    let name = ty.FullName

    let fields =
        ty.GetFields(
            System.Reflection.BindingFlags.Public
            ||| System.Reflection.BindingFlags.NonPublic
            ||| System.Reflection.BindingFlags.Instance
            ||| System.Reflection.BindingFlags.DeclaredOnly
        )
        |> Seq.filter (fun f -> f.IsSpecialName |> not)
        |> Seq.filter (fun f ->
            ()
            |> f.GetCustomAttributesData
            |> Seq.exists (fun a -> a.AttributeType.FullName.Contains "ExportAttribute"))
        |> Seq.map (fun f ->

            { name = f.Name
              ty = f.FieldType.FullName
              attributes = getAttributes f.Name (f.GetCustomAttributesData()) |> Seq.toList })

    let props =
        ty.GetProperties(
            System.Reflection.BindingFlags.Public
            ||| System.Reflection.BindingFlags.NonPublic
            ||| System.Reflection.BindingFlags.Instance
            ||| System.Reflection.BindingFlags.DeclaredOnly
        )
        |> Seq.filter (fun f ->
            ()
            |> f.GetCustomAttributesData
            |> Seq.exists (fun a -> a.AttributeType.FullName.Contains "ExportAttribute"))
        |> Seq.map (fun p ->
            { name = p.Name
              ty = p.PropertyType.FullName
              attributes = getAttributes p.Name (p.GetCustomAttributesData()) |> Seq.toList })

    let combinedFields = fields |> Seq.append props |> Seq.toList

    let methods =
        ty.GetMethods(
            System.Reflection.BindingFlags.Public
            ||| System.Reflection.BindingFlags.Instance
            ||| System.Reflection.BindingFlags.DeclaredOnly
        )
        |> Seq.filter (fun m -> not m.IsSpecialName)
        |> Seq.filter (fun m -> not m.IsAbstract)
        |> Seq.map (fun m ->
            let name = m.Name
            let ret = typeToSanitizedName m.ReturnType

            let args =
                m.GetParameters()
                |> Seq.map (fun p ->
                    { name = p.Name
                      ty = typeToSanitizedName p.ParameterType
                      attributes = getAttributes p.Name (p.GetCustomAttributesData()) |> Seq.toList })
                |> Seq.toList

            let generics =
                m.GetGenericArguments() |> Seq.map (fun g -> g.FullName) |> Seq.toList

            { name = name
              ret = ret
              args = args
              generics = generics
              attributes = getAttributes name (m.GetCustomAttributesData()) |> Seq.toList })
        |> Seq.toList

    let signalHandlers =
        ty.GetMethods(
            System.Reflection.BindingFlags.Public
            ||| System.Reflection.BindingFlags.Instance
            ||| System.Reflection.BindingFlags.DeclaredOnly
        )
        |> Seq.filter isSignalHandler
        |> Seq.map (fun m ->
            let name = m.Name

            let args =
                m.GetParameters()
                |> Seq.map (fun p ->
                    { name = p.Name
                      ty = typeToSanitizedName p.ParameterType
                      attributes = getAttributes p.Name (p.GetCustomAttributesData()) |> Seq.toList })
                |> Seq.toList

            { name = name; args = args })
        |> Seq.toList

    let proxyName = typeToProxyType ty

    { extending = name
      fields = combinedFields
      name = proxyName
      methods = methods
      signalHandlers = signalHandlers
      attributes = getAttributes name (ty.GetCustomAttributesData()) |> Seq.toList }

let attributeToString (a: attr) =
    let mutable args =
        a.args
        |> Seq.map (fun arg ->
            match arg with
            | String s -> $"\"{s}\""
            | Integer i -> $"{i}"
            | Float f -> $"{f}"
            | Float32 f -> $"{f}"
            | Enum(name, value) -> $"({name}){value}"
            | Null -> "null")
        |> String.concat ", "

    if args = "" then
        args <- $"({args})"

    let ty = a.ty.Remove(a.ty.Length - "attribute".Length, "attribute".Length)
    $"[{ty}({args})]"

let classToString nameSpace (c: CsharpClass) =
    let fields =
        c.fields
        |> Seq.map (fun f ->
            let getBody = $"get => base.{f.name};"
            let setBody = $"set\n{{ base.{f.name} = value; }}"
            let attrs = f.attributes |> Seq.map attributeToString |> String.concat "\n"
            $"{attrs}\npublic new {f.ty} {f.name} {{ {getBody} {setBody}}}")

    let methods =
        c.methods
        |> Seq.map (fun m ->
            let args = m.args |> Seq.map (fun a -> $"{a.ty} {a.name}") |> String.concat ", "
            let passAlong = m.args |> Seq.map (fun a -> a.name) |> String.concat ", "

            let generics =
                if m.generics.IsEmpty then
                    ""
                else
                    let generics = m.generics |> Seq.map (fun g -> g) |> String.concat ", "
                    $"<{generics}>"

            let ret = m.ret
            let name = m.name
            let attrs = m.attributes |> Seq.map attributeToString |> String.concat "\n"
            $"{attrs}\nnew public {ret} {name}{generics}({args}) => base.{name}({passAlong});"

        )

    let signals =
        c.signalHandlers
        |> Seq.map (fun s ->
            let strippedName = s.name.Remove(0, signalPrefix.Length)
            let delegateName = strippedName + "EventHandler"
            let argsForDelegate = s.args |> Seq.filter (fun a -> a.ty <> "void") |> Seq.toArray

            let delegateSpread =
                argsForDelegate |> Seq.map (fun a -> $"{a.ty} {a.name}") |> String.concat ", "

            let delegatePart =
                $"[Godot.Signal]\npublic delegate void {delegateName}({delegateSpread});"

            let methodSpread =
                s.args |> Seq.map (fun a -> $"{a.ty} {a.name}") |> String.concat ", "

            let callSpread = argsForDelegate |> Seq.map (fun a -> a.name) |> String.concat ", "

            let method =
                $"override public void {s.name}({methodSpread})\n{{\nthis.EmitSignal({c.name}.SignalName.{strippedName}, {callSpread});\n}}"

            $"{delegatePart}\n{method}")

    let attrs = c.attributes |> Seq.map attributeToString |> String.concat "\n"

    let classHeader = $"{attrs}\npublic partial class {c.name} : {c.extending}\n{{"

    let classFooter = "}"
    let nameSpace = $"namespace {nameSpace};"

    [ classFooter ]
    |> Seq.append fields
    |> Seq.append methods
    |> Seq.append signals
    |> Seq.append [ headerWarning; nameSpace; classHeader ]
    |> String.concat "\n"


let isTypeValidForTranslation (ty: System.Type) =

    let onlySignalsAreAbstract (ty: System.Type) =
        ty.GetMethods()
        |> Seq.forall (fun m -> if m.IsAbstract then isSignalHandler (m) else true)


    ty.IsAbstract && ty.IsClass && isExtendingGodot ty && onlySignalsAreAbstract ty

let createTypeRegisterCalls (ns: string) (c: CsharpClass) =
    let extendingType = c
    let name = $"{ns}.{c.name}"
    $"FSGlue.initialization.registerType<{extendingType.name}, {name}>();"

let createTypeRegisterClass (ns: string) (c: seq<string>) =
    let ns = $"namespace {ns};\n"

    let header =
        $"public static class Initializer\n{{\n#pragma warning disable CA2255\n[System.Runtime.CompilerServices.ModuleInitializer]\n#pragma warning restore CA2255\npublic static void Initialize()\n{{"

    let methods = c |> String.concat ";\n"
    $"{headerWarning}\n{ns}\n{header}\n{methods}\n}}}}\n"
