module writer

open System.Text

let private initFileName = "init.cs"

type public MissingFsharpFile(c: csharpGenerator.CsharpClass) =
    inherit
        System.Exception
            $"Could not find a matching file for the F# type. Ensure the filename is _exactly_ the same as the type name.\nType: {c.name}\nExpecting file named:{c.name}.fs in the project."

type public OccupiedCsharpFile(f: System.IO.FileInfo, c: csharpGenerator.CsharpClass) =
    inherit
        System.Exception
            $"There is a C# file without the correct header that would get overwritten.\nEither change the name of the C# file or delete it.\nFile:{f.FullName}\nClass:{c.name}"

type public OccupiedInitFile(f: System.IO.FileInfo) =
    inherit
        System.Exception
            $"The {initFileName} file would get overwritten and does not have the correct header.\nEither change the name of the C# file or delete it.\nFile:{f.FullName}"

let private writeText (f: System.IO.FileInfo) (text: string) =
    use writer = f.OpenWrite()
    writer.SetLength 0L
    let info = (UTF8Encoding true).GetBytes text
    writer.Write info

let writeFiles (args: argParser.Args) (files: projectExplorer.FoundFiles) (classes: seq<csharpGenerator.CsharpClass>) =

    let processedCSharpFiles = System.Collections.Generic.Dictionary()

    for c in classes do
        let fsharpFile = files.FSharpFiles.TryFind(c.name)

        let fsharpFile =
            match fsharpFile with
            | Some(f :: _ | f :: []) -> f
            | Some([]) ->
                $"Type extracted from file list, but no file found? This is a bug!.\nClass: {c.name}"
                |> System.Exception
                |> raise
            | None -> raise (MissingFsharpFile c)

        let searchingFor = System.IO.Path.ChangeExtension(fsharpFile.FullName, ".cs")

        let csharpFile =
            files.CSharpFiles
            |> Seq.tryFind (fun f ->
                match f with
                | projectExplorer.AutogeneratedCSharpFile.Auto f
                | projectExplorer.AutogeneratedCSharpFile.UserMade f -> f.FullName = searchingFor)
            |> Option.defaultWith (fun () ->
                searchingFor
                |> System.IO.FileInfo
                |> projectExplorer.AutogeneratedCSharpFile.Auto)

        let csharpFile =
            match csharpFile with
            | projectExplorer.AutogeneratedCSharpFile.Auto f -> f
            | projectExplorer.AutogeneratedCSharpFile.UserMade f -> raise (OccupiedCsharpFile(f, c))

        let generatedClass = csharpGenerator.classToString args.nameSpace c

        writeText csharpFile generatedClass

        (c, csharpFile) |> processedCSharpFiles.Add |> ignore

    processedCSharpFiles

let writeTypeRegister (args: argParser.Args) (clas: string) =

    let fullPath = args.projectRoot + "/" + initFileName
    let file = System.IO.FileInfo fullPath

    if file |> projectExplorer.headerMatchesAutoGenerated |> not then
        file |> OccupiedInitFile |> raise

    writeText file clas

let cleanupUnusedFiles
    (files: projectExplorer.FoundFiles)
    (foundClasses: System.Collections.Generic.Dictionary<csharpGenerator.CsharpClass, System.IO.FileInfo>)
    =
    let toCleanup =
        files.CSharpFiles
        |> Seq.choose (fun f ->
            match f with
            | projectExplorer.AutogeneratedCSharpFile.Auto f -> Some f
            | projectExplorer.AutogeneratedCSharpFile.UserMade f -> None)

    let classes = System.Collections.Generic.HashSet()
    let files = System.Collections.Generic.HashSet()

    for f in foundClasses do
        f.Key |> classes.Add |> ignore
        f.Value.FullName |> files.Add |> ignore

    for cleanup in toCleanup do
        let name = cleanup.FullName

        if name <> "init" && name |> files.Contains |> not then
            cleanup.Delete()

    classes
